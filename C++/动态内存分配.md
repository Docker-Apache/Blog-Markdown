---
title: 动态内存分配
date: 2021-01-06 22:07:00
tags:
    - new
    - malloc()
    - 堆
    - 栈
category:
    - C/C++
---

## 内存分配
* 堆：操作系统维护的一块特殊内存。用户可以使用 `malloc()` 实现动态内存分配，但需使用 `free()` 手动释放，从而避免内存泄露。程序运行结束时自动释放
* 栈：由系统自动分配，存放局部变量。函数结束后，自动释放该变量的内存
* 自由存储区：C++ 基于 `new` 的一个抽象概念，凡是通过 `new` 申请的内存，都称为自由存储区
* 全局（静态）存储区：存放全局变量，静态变量 `static`
* 常量存储区：存放常量（不能被修改）

## 静态变量 static
### static 的作用
* `static` 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量。未初始化时自动初始化为 0
* `static` 修饰的静态局部变量只执行初始化一次，直到程序运行结束以后才释放
* `static` 修饰的静态全局变量只能在本文件中被访问，不能被其它文件访问，即使是 `extern` 外部声明也不可以
* `static` 修饰的函数只能在本文件中调用，不能被其他文件调
* 数据安全性：使用全局变量时应该先考虑使用 `static`，类静态成员变量更能体现封装性

### 全局变量和全局静态变量的区别
* 全局变量的作用域是整个工程，在一个文件内定义的全局变量，在头文件中通过 `extern` 全局变量名的声明可以使用全局变量
* 全局静态变量的作用域是声明此变量所在的文件，其他的文件即使用 `extern` 声明也不能使用

### 静态局部变量
* 该变量在全局数据区分配内存
* 静态局部变量在程序执行到该对象的声明处时被首次初始化一次（若没有显式初始化，则被自动初始化为 0）
* 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域
## new 与 malloc() 的区别
> 属性
* `new` 是 C++ 关键字，也是运算符，可以通过 `operator new()` 实现运算符重载
* `malloc()` 是 C 语言库函数

> 申请的内存位置
* `new` 在自由存储区中进行动态内存分配，`malloc()` 在堆中进行动态内存分配
* 自由存储区不仅可以是堆（默认），还可以是静态存储区。可以通过重载 `operator new()` 实现
* `new` 可以通过 `malloc()` 实现，而 `malloc()` 不能通过 `new` 实现

> 内存分配失败时的返回值
* `new` 申请内存失败时，默认返回 `bac_alloc` 异常
* `malloc()` 申请内存失败时，返回 `NULL`

> 是否需要指定内存大小
* 使用 `new` 申请内存时无须指定内存大小，编译器会根据类型信息自行计算
* `malloc()` 需要显式地指出所需内存大小

> 返回类型安全性  
* `new` 申请内存成功时，返回指向对象的指针，指针类型与对象类型匹配，无需类型转换
* `malloc()` 申请内存成功时，返回 `void *` 指针 ，需将 `void *` 指针强制转换为所需类型

> 是否调用构造函数/析构函数

使用 `new` 申请内存时的 3 个步骤：
* 调用 `operator new()` 函数分配一块所需大小的内存
* 调用构造函数以构造对象，并为对象赋初值（未初始化则不用）
* 对象构造完成后，返回一个指向该对象的指针

使用 `delete` 释放对象内存时的 2 个步骤：
* 调用对象的析构函数
* 调用 `operator delete()` 函数释放内存

> `new[]` 和 `delete[]` 处理数组
```c++
int *a = new int;      // 构造一个未初始化的对象，并让指针 a 指向该对象
int *b = new int(3);   // 构造一个初值为 3 的对象，并让指针 b 指向该对象
int *c = new int[3];   // 构造一个 c[3] 的数组
delete a;
delete b;
delete[] c;
int *d = (int *)malloc(3 * sizeof(int));
free(d);
```